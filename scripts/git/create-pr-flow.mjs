#!/usr/bin/env node
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';
import process from 'node:process';
import { commandExists, requireCommand, run } from '../lib/cli.mjs';

function usage() {
  console.error('Usage: node scripts/git/create-pr-flow.mjs <branch-name> <commit-message> [base-branch] [pr-title] [pr-body-file]');
}

const branchName = process.argv[2] ?? '';
const commitMessage = process.argv[3] ?? '';
const baseBranch = process.argv[4] ?? 'main';
const prTitle = process.argv[5] ?? commitMessage;
const prBodyFile = process.argv[6] ?? '';
const skipBranchPrep = process.env.SKIP_BRANCH_PREP === '1';

if (!branchName || !commitMessage) {
  usage();
  process.exit(1);
}

function hasLocalBranch(branch) {
  const branchRef = `refs/heads/${branch}`;
  return run('git', ['show-ref', '--verify', '--quiet', branchRef], { allowFailure: true }).ok;
}

function checkoutOrCreateBranch(branch, baseRef = null) {
  if (hasLocalBranch(branch)) {
    run('git', ['checkout', branch], { stdio: 'inherit' });
    return;
  }

  if (baseRef) {
    run('git', ['checkout', '-b', branch, baseRef], { stdio: 'inherit' });
    return;
  }

  run('git', ['checkout', '-b', branch], { stdio: 'inherit' });
}

try {
  requireCommand('git');

  if (!run('git', ['rev-parse', '--is-inside-work-tree'], { allowFailure: true }).ok) {
    throw new Error('error: current directory is not a git repository');
  }

  if (!run('git', ['remote', 'get-url', 'origin'], { allowFailure: true }).ok) {
    throw new Error("error: git remote 'origin' not configured");
  }

  const currentBranch = run('git', ['branch', '--show-current'], { allowFailure: true }).stdout;

  if (!skipBranchPrep) {
    run('git', ['fetch', 'origin', baseBranch], { stdio: 'inherit' });

    if (hasLocalBranch(baseBranch)) {
      run('git', ['checkout', baseBranch], { stdio: 'inherit' });
      run('git', ['pull', '--ff-only', 'origin', baseBranch], { stdio: 'inherit' });
    } else {
      run('git', ['checkout', '-b', baseBranch, `origin/${baseBranch}`], { stdio: 'inherit' });
    }

    checkoutOrCreateBranch(branchName);
  } else {
    checkoutOrCreateBranch(branchName);
  }

  const gateScript = path.join('scripts', 'ci', 'governance-gate.mjs');
  if (fs.existsSync(gateScript)) {
    process.stdout.write('Running governance gate...\n');
    run('node', [gateScript, 'governance-gate-report.md'], { stdio: 'inherit' });
  }

  if (commandExists('npx')) {
    process.stdout.write('Running Playwright test discovery...\n');
    const discovery = run('npx', ['playwright', 'test', '--list', '--project=chromium'], { allowFailure: true });
    if (!discovery.ok) {
      const discoveryLog = `${discovery.stdout || ''}\n${discovery.stderr || ''}`.trim();
      fs.writeFileSync('/tmp/create-pr-flow-test-list.log', discoveryLog, 'utf8');
      process.stderr.write('warning: test discovery failed, check /tmp/create-pr-flow-test-list.log\n');
    }
  }

  run('git', ['add', '-A'], { stdio: 'inherit' });
  if (run('git', ['diff', '--cached', '--quiet'], { allowFailure: true }).ok) {
    throw new Error('error: no staged changes detected; refusing to create empty PR.');
  }

  run('git', ['commit', '-m', commitMessage], { stdio: 'inherit' });
  run('git', ['push', '-u', 'origin', branchName], { stdio: 'inherit' });

  if (commandExists('gh')) {
    const auth = run('gh', ['auth', 'status'], { allowFailure: true });
    if (auth.ok) {
      if (prBodyFile && fs.existsSync(prBodyFile)) {
        run(
          'gh',
          ['pr', 'create', '--base', baseBranch, '--head', branchName, '--title', prTitle, '--body-file', prBodyFile],
          { stdio: 'inherit' },
        );
      } else {
        const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'create-pr-flow-'));
        const bodyFile = path.join(tempDir, 'pr-body.md');
        fs.writeFileSync(
          bodyFile,
          [
            '## Summary',
            '- Automated branch, commit and push flow executed.',
            '',
            '## Validation',
            '- Governance gate executed (if configured)',
            '- Playwright test discovery attempted',
            '',
            '## Notes',
            '- Generated by scripts/git/create-pr-flow.mjs',
            '',
          ].join('\n'),
          'utf8',
        );

        try {
          run(
            'gh',
            ['pr', 'create', '--base', baseBranch, '--head', branchName, '--title', prTitle, '--body-file', bodyFile],
            { stdio: 'inherit' },
          );
        } finally {
          fs.rmSync(tempDir, { recursive: true, force: true });
        }
      }
    } else {
      process.stderr.write('warning: gh found but not authenticated.\n');
      process.stderr.write(`manual command: gh pr create --base '${baseBranch}' --head '${branchName}' --title '${prTitle}'\n`);
    }
  } else {
    process.stderr.write('warning: gh CLI not installed.\n');
    process.stderr.write(`manual command: gh pr create --base '${baseBranch}' --head '${branchName}' --title '${prTitle}'\n`);
  }

  if (currentBranch && hasLocalBranch(currentBranch)) {
    run('git', ['checkout', currentBranch], { allowFailure: true, stdio: 'inherit' });
  }
} catch (error) {
  process.stderr.write(`${error instanceof Error ? error.message : String(error)}\n`);
  process.exit(1);
}
